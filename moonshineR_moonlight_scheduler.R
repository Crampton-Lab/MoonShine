# MoonShineR - Moonlight scheduler
# An R program by C. Lok Poon, Crampton Electric Fish Lab, University of Central Florida, Copyright 2023
# A detailed guide about this program: https://lokpoon.github.io/moonshine_manual/moonlight_LED_scheduler.html

# Description:
# This script generates an LED_schedule_moon.csv schedule file for MoonShineP to re-create a moonlight regime.

# Load libraries ---------------------------

library(suncalc)
library(rpmodel)
library(dplyr)
library(lubridate)
library(REdaS)
library(npreg)
library(ggplot2)
library(beepr)
library(progress)

#---------------------------START OF PARAMETER SETTINGS---------------------------

# (!) indicates a user specified setting

# Set working directory:
setwd("/Users/lokpoon/Desktop") # (!) .csv and .png files will be saved to this directory

# Set the location and time ---------------------------
latitude <- -4.21528 # (!) Latitude in decimal degrees (e.g., -4.21528)
longitude <- -69.94056 # (!) Longitude in decimal degrees (e.g., -69.94056)
site_elev <- 0 # (!) Site elevation in meters (e.g., 0 = sea level).
# Elevation correction applies to moonlight but not sunlight and twilight.
# The user can determine the site elevation of a coordinate location using https://www.dcode.fr/earth-elevation

time_zone <- "EST" # (!) Set the time zone for the location set (e.g., “EST”). REMEMBER TO CHANGE THE TIME ZONE WHEN THE LOCATION IS CHANGED.
# For a list of time zone names, enter OlsonNames(tzdir = NULL) in R console
# Use a time zone without DST. E.g., use "EST" instead of "America/New_York"
date_start <- "2023-03-01" # (!) Starting date of the simulation (YYYY-MM-DD)
time_start <- "18:00:00" # (!) Starting time of the simulation (hh:mm:ss)
duration_day <- 1 # (!) Duration of simulation in days

# Set nominal dark sky value ---------------------------
# Adding a baseline illumination to the model to represent other nocturnal light sources (e.g., starlight and airglow) (Hänel et al. 2017) 
darksky_value <- 0.0008 # (!) Default = 0.0008
# change it to zero if a complete darkness (during moonless night) is preferred (i.e., no starlight or skyglow)

# LED strip configuration---------------------------

theoretical_max <- 0.4 # (!) Define an intensity upper limit (in lx) so that the LED system is not instructed to exceed 100% output intensity.
## Refer to online MoonShine Manual part 7.
## Increasing theoretical_max will reduce the illuminance to the LED.

diode_per_strip <- 144 # (!) Number of LEDs per strip
strip_count <- 2 # (!) Number of daisy-chained LED strips

# LED spectral control---------------------------
# Input the intensity fraction (0-1) each LED color is outputting. Each is independent. 
white_fraction <- 1.0 # (!) White. Default = 1.0
red_fraction <- 0.08 # (!) Red. Default = 0.08
green_fraction <- 0.36 # (!) Green. Default = 0.36
blue_fraction <- 0.19 # (!) Blue. Default = 0.19
# These default RGBW fractions approximate the spectrum of moonlight when used with the intended SK6812 RGBW LED strip, with 'warm white' specification.
# To change color balance from white to, for example, a red-shifted light, the user can increase the red_fraction, incrementally, until the color generated by lightbox reaches the desired parameters on a spectrometer.
# See manual for citations of papers that describe the color properties of different natural habitats. 

# Horizon obstruction---------------------------
# Recreate potential obstructions of moonlight from the horizon (anywhere except sea level). E.g., tall mountain range or trees around a forest gap.
horizon_option <- FALSE # (!) TRUE to enable
horizon_transition_end <- 57 # (!) angular altitude* ABOVE which there is a zone of unobstructed illumination. We define this as Zone A.
horizon_elev <- 55 # (!) angular altitude* BELOW which there is maximum light attenuation (e.g., due to a mountain or tree line). We DEFINE THIS AS ZONE C.
# * The angular altitude refers to the angle above the horizon, from 0 degrees at the horizon to 90 degrees at the zenith.
horiz_transmission <- 0.15 # (!) the proportional transmission of light in Zone A relative to Zone C. For example, if a value of 0.15 is chosen, and horizon_elev is set to 55, light level in the zone below 55 degrees will be 15% of the light level above the angle of “horizon_transition_end”.
# Zones A and C delimit a third, intervening zone B (e.g., between 55 and 60 degrees above the horizon). A linear transition of light level is applied between horizon_elev and horizon_transition_end. This makes light level transitions less abrupt when the simulated moon rises above simulated obstacles. 

# Cloud cover settings ---------------------------
cloud_option <- FALSE # (!) TRUE to enable cloud simulator
# User should review graphical output of simulation in the next section, and adjust parameters accordingly, before deployment of the simulation with MoonShineP.
date_start_cloud <- date_start # (!) starting date of cloud effect (YYYY-MM-DD)
time_start_cloud <- time_start # (!) starting time of cloud effect (hh:mm:ss)
duration_day_cloud <- duration_day # (!) duration of the cloud effect
cloud_change_freq <- 30 # (!) Sets how quickly the clouds are transitioning (in minutes). Set this value to > or = 5. A value of <5 may crash R session.
# A value of 5 simulates rapid movement of clouds across the moon’s disk due to high-speed winds at cloud altitude. A value of 30 represents very slow cloud movement.
transmission_mean <- 1 # (!) Set the mean of the normal distribution. A value of 1 means cloud simulator is using only the ‘left’ half of the normal distribution. This simulates an occasional cloud passing across the moon.
# A value over 1 will reduce the frequency and extremity of cloud cover (we recommend values not exceeding 2).
# Zero or a negative value will use the right side of the normal distribution – simulating denser cloud cover with occasional periods of no cloud cover (we recommend values no lower than -1). Avoid using a value between 0 and 1.

transmission_sd <- 0.5 # (!) Set the SD of the of the normal distribution. We recommend starting at 0.5, and increasing or decreasing this value slightly (e.g. change to 1.5) to thicken or thin the simulated passing clouds.
# The user can create ‘tailored’ weather changes by running MoonShineR moonlight scheduler for a defined start and end period, using one set of cloud simulator parameters, and then running the entire simulation for a subsequent period of time, this time using a new set of cloud simulator parameters. The user can then manually concatenate the data in the .csv files.
# This procedure can be repeated for as many major transitions in weather are required during a simulation. 

# The cloud simulator works by applying a cloud_table dataframe that contains the proportional moonlight transmission value for each minute (recalling that lightbox operations are constrained to changes in light every minute as defined by time_interval_minutes).
# The cloud_table dataframe is generated in two stages. First, it create a set of random data points (each representing simulated light transmission values for a given time), with the value of these data points constrained within a normal distribution.
# The user is able to control the following parameters of this normal distribution: 1) the mean; 2) the standard deviation; 3) the number of values per unit time, with 1 value per minute being the minimum. The cloud simulator then applies a smoothing spline to this distribution to create a smooth transition in light transmission.
# Finally values from this spline are interpolated at one minute intervals to provide the required values for light generation by the LED array.

#--------------------------- START OF CLOUD EFFECT GENERATOR ---------------------------

time_interval_minutes <- 1 # The temporal resolution of the simulation in minutes. Locked at 1 for MoonShineP to operate correctly.
bit8 <- 255 # Controllable light intensity level of the LEDs is 255 (8 bit).

# Prepare a table for cloud stochastic values and plot
# Beware that the cloud effect is generated randomly, within the desired parameters, every time if “set.seed(1)” is commented out. 
#enabling “set.seed(1)” by uncommenting this line  will replicate the exact same cloud settings #every time the script is run (assuming all settings remain identical)

if (cloud_option == TRUE) {
  date_time_start_cloud <- as_datetime(paste(date_start_cloud, time_start_cloud, sep = " ", collapse = NULL), tz = time_zone)
  number_of_interval_cloud <- as.numeric(days(duration_day_cloud)) / as.numeric(dminutes(time_interval_minutes))
  cloud_table <- data.frame(matrix(ncol = 1, nrow = number_of_interval_cloud / cloud_change_freq))
  colnames(cloud_table) <- c("x")
  
  # set.seed(1) # (!) enable this line if desired (see commenting above)
  cloud_table$cloud_transmission <- rnorm(n = number_of_interval_cloud / cloud_change_freq, mean = transmission_mean, sd = transmission_sd)
  
  time_interval_cloud_list <- seq(1, number_of_interval_cloud / cloud_change_freq, by = 1) 
  for (i in time_interval_cloud_list) {
    cloud_table[i, "datetime"] <- getMoonIllumination(date = date_time_start_cloud + ((i - 1) * (time_interval_minutes * cloud_change_freq) * 60))[1, "date"]
  }
  cloud_table <- subset(cloud_table, select = -c(x))
  
  par(mfrow = c(1,1))
  
  # Plot the spline fit to visualize cloud transmission that will be applied:
  mod.ss0 <- ss(cloud_table$datetime, cloud_table$cloud_transmission, all.knots = TRUE, lambda = (1 / number_of_interval_cloud) * 1e-12) 
  # The lambda multiplied constant can be reduced to create less abrupt transitions.
  # However, in most cases, the default 1e-12 can be left unchanged as it closely resembles the abrupt change of light caused by passing cloud.
  # An increase in the lambda value (e.g., to 1e-8) will make the transition slightly smoother but at the expense of narrowing the range of used values. 
  
  plot(mod.ss0, ylim = c(0, 1), xlab = "duration of cloud effect", ylab = "fraction of light that passes through cloud")
  points(cloud_table$datetime, cloud_table$cloud_transmission)
}

# Calculate the cloud effect on each minute
if (cloud_option == TRUE) {
  smoothing_cloud <- mod.ss0 # (!) select smoothing model from above
  
  time_interval_cloud_list_full <- seq(1, number_of_interval_cloud, by = 1)
  cloud_table_full <- data.frame(matrix(ncol = 1, nrow = number_of_interval_cloud))
  colnames(cloud_table_full) <- c("x")
  
  for (i in time_interval_cloud_list_full) {
    cloud_table_full[i, "datetime"] <- getMoonIllumination(date = date_time_start_cloud + (i - 1) * time_interval_minutes * 60)[1, "date"]
    cloud_table_full[i, "cloud_transmission"] <- predict(smoothing_cloud, cloud_table_full[i, "datetime"] , deriv = 0)[1, 2]
    if (cloud_table_full[i, "cloud_transmission"] > 1) {cloud_table_full[i, "cloud_transmission"] <- 1}
    if (cloud_table_full[i, "cloud_transmission"] < 0) {cloud_table_full[i, "cloud_transmission"] <- 0}
  }
  cloud_table_full <- subset(cloud_table_full, select = -c(x))
}

#--------------------------- END OF CLOUD EFFECT GENERATOR---------------------------
#--------------------------- END OF PARAMETER SETTINGS---------------------------

#---------------------------START OF ILLUMINATION COMPUTATION-------------------

# Start time formatting
date_time_start <- as_datetime(paste(date_start, time_start, sep = " ", collapse = NULL), tz = time_zone)
number_of_interval <- as.numeric(ddays(duration_day)) / as.numeric(dminutes(time_interval_minutes))

# Create an empty dataframe (to be filled during the for loop)
moon_value_table <- data.frame(matrix(ncol = 1, nrow = number_of_interval))
x <- c("x")
colnames(moon_value_table) <- x

# Create for loop [i] time interval list
time_interval_list <- seq(1, number_of_interval, by = 1) 

# Create a progress bar object
pb <- progress_bar$new(total = length(time_interval_list))

# Fill in empty data frame with suncalc data
for (i in time_interval_list) {
  moon_value_table[i, "datetime"] <- getMoonIllumination(date = date_time_start + (i - 1) * time_interval_minutes * 60)[1, "date"]
  moon_value_table[i, "phase_angle"] <- (getMoonIllumination(date = date_time_start + (i - 1) * time_interval_minutes * 60)[1, "phase"]) * (-360) + 180 #phase_angle = angular separation of the sun and Earth, as seen on the moon
  moon_value_table[i, "fraction"] <- (getMoonIllumination(date = date_time_start + (i - 1) * time_interval_minutes*60)[1, "fraction"]) # moon illuminated fraction, not used in calculation. This is calculated only for user to learn about the moon phase.
  moon_value_table[i, "Z_moon"] <- 90 - (rad2deg(getMoonPosition(date = date_time_start + (i - 1) * time_interval_minutes * 60, lat = latitude, lon = longitude)[1, "altitude"])) #Z_moon = Zenith distance in degree of the moon = 90 - moon altitude
  moon_value_table[i, "distance"] <- getMoonPosition(date = date_time_start + (i - 1) * time_interval_minutes * 60, lat = latitude, lon = longitude)[1, "distance"] #distance = moon/Earth distance in km
  moon_value_table[i, "sun_altitude"] <- rad2deg(getSunlightPosition(date = date_time_start + (i - 1) * time_interval_minutes * 60, lat = latitude, lon = longitude, keep = c("altitude"))[1, "altitude"]) #sun_altitude = altitude in degree of the sun
  pb$tick() # Update the progress bar
}
moon_value_table <- subset(moon_value_table, select = -c(x))

# Replace moon altitude that are lower than horizon_elev with NA (moon below horizon)
moon_value_table <- transform(moon_value_table, Z_moon = ifelse(Z_moon > 90, NA, Z_moon)) 

# Calculate atmospheric extinction
moon_value_table$atm_ext <- (-0.140194 * moon_value_table$Z_moon) / (-91.674385 + moon_value_table$Z_moon) - 0.03 # A Michaelis-Menten that fits Table 2 in Austin et al. (1976)
moon_value_table$atm_ext <- ifelse(moon_value_table$atm_ext < 0, 0, moon_value_table$atm_ext)

# Moon magnitude calculated from phase angle (unit in relative magnitude) (Allen 1976, p. 144)
moon_value_table$m <- (-12.73) + 0.026 * abs(moon_value_table$phase_angle) + 4 * (10 ^ -9) * (abs(moon_value_table$phase_angle) ^ 4)

# Temporary illuminance of moonlight (in unit foot candle) (see eq. (16) of Schaefer 1990a)
illuminance_temp <- 10 ^ ((-0.4) * (moon_value_table$m + moon_value_table$atm_ext + 16.57)) 
moon_value_table$illuminance_temp_lux <- illuminance_temp * 10.7639 #convert to lux

# Correct for the effect of site altitude (i.e., elevation)
atm_pressure_relative_to_sea <- patm(site_elev, patm0 = 101325) / 101325 # the atmospheric pressure at the site elevation relative to sea level
sea_555nm <- 18.964 * exp(-0.229 * 1) # Sea level irradiance at 555nm. Function extracted from figure 1 of Laue (1970)
elevated_555nm <- 18.964 * exp(-0.229 * atm_pressure_relative_to_sea) # Sea level irradiance at 555nm. Function extracted from figure 1 of Laue (1970)
increase_factor_elev <- elevated_555nm / sea_555nm 
moon_value_table$illuminance_temp_lux <- moon_value_table$illuminance_temp_lux * increase_factor_elev

# Apply lunar opposition surge when p < 6 (Buratti et al. 1996, figure 5)
moon_value_table <- transform(moon_value_table, illuminance_temp_lux = ifelse(abs(phase_angle) < 6, illuminance_temp_lux + ((0.4 * (6 - abs(phase_angle)) / 6) * illuminance_temp_lux), illuminance_temp_lux)) 
## A linear increase in moon brightness as phase angle decreases below 6

# Apply spreading out effect (angle of incidence) of light when illuminating at an angle (Austin et al. 1976)
moon_value_table$moon_final_lux <- moon_value_table$illuminance_temp_lux * sin(deg2rad(90 - moon_value_table$Z_moon))

# The moon/Earth distance effect (inverse square law) (Austin et al. 1976)
moon_value_table$moon_final_lux <- moon_value_table$moon_final_lux * (1 / ((moon_value_table$distance / 384400) ^ 2))

# Waxing - waning asymmetric effect (simplified function derived from Austin et al. 1976 Table 1)
moon_value_table$moon_final_lux <- ifelse(moon_value_table$phase_angle < 0,
                                          moon_value_table$moon_final_lux * (-0.00026 * moon_value_table$phase_angle + 1),
                                          moon_value_table$moon_final_lux)

# Final moonlight illuminance (with a slight adjustment factor, calibrated from Leticia, Colombia, Aug 11, 2022 field full moon measurement)

moon_value_table$moon_final_lux <- moon_value_table$moon_final_lux * 0.863
moon_value_table$moon_final_lux <- replace(moon_value_table$moon_final_lux, is.na(moon_value_table$moon_final_lux), 0)


#---------------------------APPLY CLOUD AND HORIZON ELEVATION EFFECT---------------------------

# Horizon elevation effect
if (horizon_option == TRUE) {
  moon_value_table <- transform(moon_value_table, moon_final_lux = ifelse((90 - Z_moon) > horizon_elev & (90 - Z_moon) < horizon_transition_end, 
                                                                          moon_final_lux - (moon_final_lux * (1 - horiz_transmission) * (abs(90 - Z_moon - horizon_transition_end) / (horizon_transition_end - horizon_elev))), moon_final_lux)) 
  moon_value_table <- transform(moon_value_table, moon_final_lux = ifelse((90 - Z_moon) < horizon_elev, moon_final_lux * horiz_transmission, moon_final_lux)) 
}

# Add baseline dark sky illuminance (Note: darsky_value is not affected by the horizon obstruction, but is subjected to the cloud effect)
moon_value_table$moon_final_lux[is.na(moon_value_table$moon_final_lux)] <- 0
moon_value_table$moon_final_lux <- moon_value_table$moon_final_lux + darksky_value 

# Cloud effect
if (cloud_option == TRUE) {
  moon_value_table <- left_join(moon_value_table, cloud_table_full, by = "datetime")
  moon_value_table <- moon_value_table %>%
    mutate(cloud_transmission = if_else(is.na(cloud_transmission), 1, cloud_transmission))
  moon_value_table$moon_final_lux <- moon_value_table$moon_final_lux * moon_value_table$cloud_transmission
}

#---------------------------END OF ILLUMINATION COMPUTATION--------------------

#---------------------------GENERATE LED_schedule_moon.csv---------------------------

#Scale the model illumination to an intensity fraction by dividing it by theoretical_max
recreate_intensity_fraction <- moon_value_table$moon_final_lux / theoretical_max

#Calculate the RGBW crude and fine values for moonlight recreation
temp_white_intensity <- recreate_intensity_fraction * bit8 * white_fraction
crudewhite <- floor(temp_white_intensity)
wfine <- floor((temp_white_intensity - crudewhite) * diode_per_strip * strip_count)

temp_red_intensity <- recreate_intensity_fraction * bit8 * red_fraction
crudered <- floor(temp_red_intensity)
rfine <- floor((temp_red_intensity - crudered) * diode_per_strip * strip_count)

temp_green_intensity <- recreate_intensity_fraction * bit8 * green_fraction
crudegreen <- floor(temp_green_intensity)
gfine <- floor((temp_green_intensity - crudegreen) * diode_per_strip * strip_count)

temp_blue_intensity <- recreate_intensity_fraction * bit8 * blue_fraction
crudeblue <- floor(temp_blue_intensity)
bfine <- floor((temp_blue_intensity - crudeblue) * diode_per_strip * strip_count)

#Fill moon_value_table with LED color crude and fine values. NA converted to 0.
moon_value_table$crudewhite <- crudewhite
moon_value_table <- transform(moon_value_table, crudewhite = ifelse(is.na(crudewhite), 0, crudewhite)) 

moon_value_table$wfine <- wfine
moon_value_table <- transform(moon_value_table, wfine = ifelse(is.na(wfine), 0, wfine)) 

moon_value_table$crudered <- crudered
moon_value_table <- transform(moon_value_table, crudered = ifelse(is.na(crudered), 0, crudered)) 

moon_value_table$rfine <- rfine
moon_value_table <- transform(moon_value_table, rfine = ifelse(is.na(rfine), 0, rfine))

moon_value_table$crudegreen <- crudegreen
moon_value_table <- transform(moon_value_table, crudegreen = ifelse(is.na(crudegreen), 0, crudegreen)) 

moon_value_table$gfine <- gfine
moon_value_table <- transform(moon_value_table, gfine = ifelse(is.na(gfine), 0, gfine))

moon_value_table$crudeblue <- crudeblue
moon_value_table <- transform(moon_value_table, crudeblue = ifelse(is.na(crudeblue), 0, crudeblue)) 

moon_value_table$bfine <- bfine
moon_value_table <- transform(moon_value_table, bfine = ifelse(is.na(bfine), 0, bfine)) 

moon_value_table <- subset(moon_value_table, select = -c(atm_ext, m, illuminance_temp_lux)) # remove extra columns


# Save moon table csv file
write.csv(moon_value_table,"LED_schedule_moon.csv", row.names = TRUE)

# Explanation for the columns found in LED_schedule_moon.csv:
# Use whichever illuminance prediction is appropriate for desired use. 

## datetime = The datetime in a standard format that R and moonshine_moon.py can read
## phase_angle = the phase angle of the moon
## fraction = the illuminated fraction of the moon
## Z_moon = zenith distance of the moon in degree angle
## distance = the moon and Earth distance in km
## sun_altitude = The altitude of the sun. Positive/negative value means the sun is above/below the horizon, respectively.
## moon_final_lux = illuminance of moonlight (plus the darksky_value)
## crude and fine LED values for each RGBW = the LED values that moonshine_moon.py will use instruct the LED at the given time.

#---------------------------Plotting Section---------------------------

# Plotting the moonlight illuminance that will be re-created.
# Dark gray areas depict dark periods (true night after astronomical twilight ended).
# Light gray areas indicate periods of astronomical twilight.

# Create a clean ggplot theme
theme_rectangular_clean <-
  theme(axis.line = element_line(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank()) +
  theme(axis.text = element_text(size = 12, colour = 'black'),
        axis.title = element_text(size = 12, colour = 'black')) +
  theme(plot.title = element_text(size = 12)) +
  theme(plot.margin = unit(c(0.25,0.25,0.25,0.25),"cm"))

# Specify the time of night period and twilight period for shading
night_time <- filter(moon_value_table, sun_altitude < 0) %>% dplyr::select(datetime)
night_time <- as_datetime(night_time$datetime, tz = time_zone)

after_twilight_time <- filter(moon_value_table, sun_altitude < (-18)) %>% dplyr::select(datetime)
after_twilight_time <- as_datetime(after_twilight_time$datetime, tz =  time_zone)

day_time <- filter(moon_value_table, sun_altitude > 0) %>% dplyr::select(datetime)
day_time <- as_datetime(day_time$datetime, tz = time_zone)

# Plotting:
plot_output <- ggplot() + theme_rectangular_clean +
  geom_rect(aes(xmin = night_time, # night period
                xmax = night_time + dminutes(time_interval_minutes),
                ymin = 0, ymax = Inf), fill = "grey88", alpha = 1, na.rm = TRUE) +
  geom_rect(aes(xmin = after_twilight_time, # after twilight
                xmax = after_twilight_time + dminutes(time_interval_minutes),
                ymin = 0, ymax = Inf), fill = "grey80", alpha = 1, na.rm = TRUE) +
  geom_line(data = moon_value_table, aes(x = datetime, y = moon_final_lux), colour = 'black', linewidth = 0.75) +
  geom_rect(aes(xmin = day_time, # day time mask moonlight regression to gray color
                xmax = day_time + dminutes(time_interval_minutes),
                ymin = 0, ymax = Inf), fill = "white", alpha = 0.85, na.rm = TRUE) +
  scale_y_continuous(limits = c(0, 0.3), # change the y-axis range here
                     breaks = c(seq(from = 0, to = 0.3, by = 0.1))) + # change the y-axis breaks here
  scale_x_datetime(date_breaks = "1 day") + # change the date break here for different x-axis label. More specific format can be specified.
  labs(x = "", y = "predicted ground illuminance (lx)") 


plot_output

beep()

# Save plot:
ggsave("moon_plot_output.png", plot_output, width = 4488, height = 2000, units = "px", scale = 1, dpi = 450)
## .png can be changed to .pdf to save as a vector file.
## However when exporting as .pdf, the shading transparency (alpha setting) might not look right. This is a limitation of R.

#---------------------------Lunar eclipse warning---------------------------

# MoonShineR warns the user if an eclipse occurs during a simulation, and it reports the start and end time of the simulation.
# However, MoonShineR does not simulate the reduction in moon ground illuminance associated with the eclipse.

if (any(abs(moon_value_table$phase_angle) < 1.5 & moon_value_table$sun_altitude < 0)) { # eclipse defined as a moon with phase angle < 1.5 during nighttime
  print("ECLIPSE IN SIMULATION!!!")
  eclipse_list <- (abs(moon_value_table$phase_angle) < 1.5 & moon_value_table$sun_altitude < 0)
  moon_value_table[which(eclipse_list == TRUE),]
} else {
  print("no eclipse in simulation")
}

#---------------------------END OF SCRIPT---------------------------

# References ---------------------------  

# Allen, C. W. (1976). Astrophysical quantities (3rd ed. 1973, Repr. with corrections 1976). Athelone Press.; [Distributor for] U.S.A. and Canada, Humanities Press.
# Austin, R. H., Phillips, B. F., & Webb, D. J. (1976). A method for calculating moonlight illuminance at the earth’s surface. The Journal of Applied Ecology, 13(3), 741. https://doi.org/10.2307/2402251
# Buratti, B. J., Hillier, J. K., & Wang, M. (1996). The lunar opposition surge: Observations by clementine. Icarus, 124(2), 490–499. https://doi.org/10.1006/icar.1996.0225
# Hänel, A., Posch, T., Ribas, S. J., Aubé, M., Duriscoe, D., Jechow, A., Kollath, Z., Lolkema, D. E., Moore, C., Schmidt, N., Spoelstra, H., Wuchterl, G., & Kyba, C. C. M. (2018). Measuring night sky brightness: Methods and challenges. Journal of Quantitative Spectroscopy and Radiative Transfer, 205, 278–290. https://doi.org/10.1016/j.jqsrt.2017.09.008
# Krisciunas, K., & Schaefer, B. E. (1991). A model of the brightness of moonlight. Publications of the Astronomical Society of the Pacific, 103, 1033. https://doi.org/10.1086/132921
# Laue, E. G. (1970). The measurement of solar spectral irradiance at different terrestrial elevations. Solar Energy, 13(1), 43–57. https://doi.org/10.1016/0038-092X(70)90006-X
# Schaefer, B. E. (1990). Telescopic limiting magnitudes. Publications of the Astronomical Society of the Pacific, 102, 212. https://doi.org/10.1086/132629
# Seidelmann, P. K., United States Naval Observatory, & Great Britain (Eds.). (1992). Explanatory supplement to the Astronomical almanac (Rev. ed.). University Science Books.

# Notes ---------------------------  

## Be careful with radian and degree angle
### Calculations in Krisciunas & Scaefer 1991 model uses degree angle
### suncalc functions gives radian. R trigonometry function takes radian.

## Zenith distance of the moon = 90 degree angle - moon altitude

## Phase output from suncalc::getMoonIllumination:
### 0 = new moon
### 0.25 = first quarter (waxing)
### 0.5 = full
### 0.75 = third/last quarter (waning)

## To convert phase to phase angle (following the sign convention of Krisciunas & Schaefer 1991):
### phase_angle <- phase*(-360)+180
#### positive = waxing 
#### negative = waning 
#### 180 = new moon
#### 90 = 1st quarter (waxing)
#### 0 = full
#### -90 = 2nd quarter (waning)