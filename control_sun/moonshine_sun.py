import time                from rpi_ws281x import *  # To control the LEDsimport argparseimport csv                # To work with csv filesimport os#-------------------------------------------------------# Function to clear terminalLED_COUNT      = 576     # Number of LEDsLED_PIN        = 21      # GPIO pin connected to the LED stripLED_FREQ_HZ    = 800000  # LED signal frequency in hertz (usually 800khz)LED_DMA        = 10      # DMA channel to use for generating signal (try 10)LED_BRIGHTNESS = 255    # 255 levelsLED_INVERT     = False   # True to invert the signal (when using NPN transistor level shift)LED_CHANNEL    = 0       # Set to '1' for GPIOs 13, 19, 41, 45 or 53LED_STRIP = ws.SK6812_STRIP_GRBW    # The GRBW order is correct for addressing the corrosponding channels on the BTF-Lighting LED strips. The order of the GRBW letters can be rearranged to accommodate another RGBW protocol.# This funtion retrieves the Pi current time using the time library and returns itdef gettime():    # Epoch time    etime = time.time()    # Convert to local time    ltime = time.localtime(etime)    # Return the results as separate variables in the correct format    return time.strftime("%Y", ltime),time.strftime("%m", ltime),time.strftime("%d", ltime),time.strftime("%H", ltime),time.strftime("%M", ltime),time.strftime("%S", ltime) # Return epoch timedef timestart():    etime=time.time()    ltime= time.ctime(etime)    return etime# Defines class ledclass led:    def __init__(self,r,g,b,w):        self.r=r        self.g=g        self.b=b        self.w=w# Print the input for a specific LED on the stripdef printled(strip,i):  # Opens log.txt to append  file = open("/home/pi/Desktop/control_sun/log.txt", "a")  # This is where the data is written to the file  file.write('\n| led ' + str(i) + ' r ' + str(strip[i].r) + ' g ' +str(strip[i].g) + ' b ' +str(strip[i].b) + ' w ' + str(strip[i].w) + '|')  file.close()  # Print the same to the terminal  print("----------------------------")  print('| led ' + str(i) + ' r ' + str(strip[i].r) + ' g ' +str(strip[i].g) + ' b ' +str(strip[i].b) + ' w ' + str(strip[i].w) + '|')  print("----------------------------")# Creates a "virtual strip" for calculating the intensity level of each LEDsdef fillvstrip(LED_COUNT,STRIP,rfill,rfine,gfill,gfine,bfill,bfine,wfill,wfine):# All LEDs in the strip are assigned the apropriate "fill" intensity level    for i in range(LED_COUNT):# Red diode        STRIP[i].r =rfill;# Green diode        STRIP[i].g =gfill;# Blue diode        STRIP[i].b= bfill;# White diode        STRIP[i].w= wfill;# Variables are set to one and are used as counters for increasing the LEDs properly    rcount1,rcount2=1,1    gcount1,gcount2=1,1    bcount1,bcount2=1,1     wcount1,wcount2=1,1# For every LED in the range of the fine level, alter the red diode if neccisary.    for i in range(rfine):    # If index is odd number, increase brightness of the matching number LED       if i%2!=0:            # Increase brigness by one           STRIP[i-rcount2].r = rfill+1            # Increase counter           rcount2 +=1       else:           # If the index is an even number, increase the of the LEDs starting from halfway down the strip.            STRIP[i+int((LED_COUNT/2))-rcount1+1].r = rfill+1             # Increase counter            rcount1 +=1# For every LED in the range of the fine level, alter the green diode if neccisary.    for i in range(gfine):    # If index is odd number, increase brightness of the matching number LED       if i%2!=0:            # Increase brigness by one            STRIP[i-gcount2].g = gfill+1            # Increase counter            gcount2 +=1       else:           # If the index is an even number, increase the of the LEDs starting from halfway down the strip.            STRIP[i+int((LED_COUNT/2))-gcount1+1].g = gfill+1             # Increase counter            gcount1 +=1     # For every LED in the range of the fine level, alter the blue diode if neccisary.    for i in range(bfine):    # If index is odd number, increase brightness of the matching number LED       if i%2!=0:           # Increase brigness by one           STRIP[i-bcount2].b = bfill+1            # Increase counter           bcount2 +=1       else:           # If the index is an even number, increase the of the LEDs starting from halfway down the strip.            STRIP[i+int((LED_COUNT/2))-bcount1+1].b = bfill+1             # Increase counter            bcount1 +=1# For every LED in the range of the fine level, alter the white diode if neccisary.    for i in range(wfine):        # if odd number index        if i % 2 != 0:            # Increase brigness by one            STRIP[i - wcount2].w = wfill + 1            # Increase counter            wcount2 += 1        else:            # If the index is an even number, increase the of the LEDs starting from halfway down the strip.            STRIP[i + int((LED_COUNT / 2)) - wcount1 + 1].w = wfill + 1            # Increase counter            wcount1 += 1    return STRIP # Take the strip and virtual strip as parameters. prints virtual strip to real stripdef colorWipe3(strip, vstrip):# For every LEDs    for i in range(strip.numPixels()):        # Variable holds color made from the values found in the virtual strip        color=Color(vstrip[i].r,vstrip[i].g,vstrip[i].b,vstrip[i].w)        # Set pixel color of real led to virtual led level        strip.setPixelColor(i, color)    # Execute changes    strip.show()       def clear():    command = 'clear'    if os.name in ('nt', 'dos'):  # If Machine is running on Windows, use cls        command = 'cls'    os.system(command)    clear()# Funtion to match a search term to find a specific row# Input is a csv file. It requires the term being searched for, and the title of the column you are searching indef search(filename,term):    # Open the csv that is passed as filename    with open(filename, newline='') as csvfile:        # Reader variable that can be parsed        reader = csv.DictReader(csvfile)        search=1          # Parsing through all rows in the reader        for row in reader:            # When the value is found in the column "datetime"  that matches the current Pi time            if row['datetime'] == term:                # Open the log                file = open("/home/pi/Desktop/control_sun/log.txt", "a")                # Print the data that is found in the csv                file.write("found at "+str(term)+" "+str(row['crudered'])+str(row['rfine'])+str(row['crudegreen'])+str(row['gfine'])+str(row['crudeblue'])+str(row['bfine'])+str(row['crudewhite'])+str(row['wfine']))                # Close log                file.close()                                                                         # Print the same to the terminal                print("found at ",term," ",row['crudered'],row['rfine'],row['crudegreen'],row['gfine'],row['crudeblue'],row['bfine'],row['crudewhite'],row['wfine'])                search=0                # Returns the values found under their respective headers in the csv                return (row['crudered'],row['rfine'],row['crudegreen'],row['gfine'],row['crudeblue'],row['bfine'],row['crudewhite'],row['wfine'])      # Main program logic follows:if __name__ == '__main__':    # Process arguments    parser = argparse.ArgumentParser()    parser.add_argument('-c', '--clear', action='store_true', help='clear the display on exit')    args = parser.parse_args()    # Create NeoPixel object with appropriate configuration.    strip = Adafruit_NeoPixel(LED_COUNT, LED_PIN, LED_FREQ_HZ, LED_DMA, LED_INVERT, LED_BRIGHTNESS, LED_CHANNEL, LED_STRIP)    # Intialize the library (must be called once before other functions).    strip.begin()    # Initializing variables for future use    rfill,rfine,gfill,gfine,bfill,bfine,wfill,wfine=0,0,0,0,0,0,0,0    vstrip=[]    # In range of number of lights assigned by LED_COUNT    vstrip = [led(0,1,2,3) for i in range(LED_COUNT)]    # Assign the variable vstrip by calling fillvstrip(). This initializes the strip and assigns all power levels the value of 0    vstrip = fillvstrip(LED_COUNT,vstrip,rfill,rfine,gfill,gfine,bfill,bfine,wfill,wfine)    try:        # Clear log from last time the code was ran        file = open("/home/pi/Desktop/control_sun/log.txt", "w")        file.close()        while True:            # Get the real current time and assign appropriate variables for futute formatiing            year,month,day,hour,minute,second=gettime()            # This code will continue when the current time is a whole minute. This is because the data found in the csv is going to be at one-minute intervals            if(second=="00"):                # Creates a string which is formated the same as the "datetime" row in the csv                searcht=str(year)+"-"+str(month)+"-"+str(day)+" "+str(hour)+":"+str(minute)+":"+str(second)                # Hold values returned by search function                result = search('/home/pi/Desktop/control_sun/LED_schedule_sun.csv', searcht)                # If result is not null, a data was found                if result:                    # Assign it to its respective variable                    rfill, rfine, gfill, gfine, bfill, bfine, wfill, wfine = result                else:                    # If null                    print("No matching term was found in the CSV file")                # Casecatching for if there is a matching datetime but no brightness values found at that time. This would occur when the moon is not above the horizion                if (rfill == "#VALUE!"):                    rfill = 1                if (rfine == "#VALUE!"):                    rfine = 1                if (gfill == "#VALUE!"):                    gfill = 1                if (gfine == "#VALUE!"):                    gfine = 1                if (bfill == "#VALUE!"):                    bfill = 1                if (bfine == "#VALUE!"):                    bfine = 1                if (wfill == "#VALUE!"):                    wfill = 1                if (wfine == "#VALUE!"):                    wfine = 1                                # Casting all values to int data type                rfill, rfine, gfill, gfine, bfill, bfine, wfill, wfine = int(rfill), int(rfine), int(gfill), int(gfine), int(bfill), int(bfine), int(wfill), int(wfine)                                                                                      # Fill the virtual strip with the values found in the csv                vstrip = fillvstrip(LED_COUNT, vstrip, rfill, rfine, gfill, gfine, bfill, bfine, wfill, wfine)                              # Apply changes to real strip, making it match the data stored in the virtual strip                colorWipe3(strip, vstrip)                # Print what should be displaying on the light strip for the given number of LEDs                 for i in range(3):  # Parameter is number of LEDs from virtual strip that are printed                    printled(vstrip, i)                time.sleep(52)  # Parameter is time in seconds the program will wait before checking the clock again                   except KeyboardInterrupt:        if args.clear:            colorWipe(strip, Color(0,0,0,0), 10)