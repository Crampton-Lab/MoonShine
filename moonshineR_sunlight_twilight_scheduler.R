# MoonShineR - Sunlight/twilight LED scheduler
# An R program by C. Lok Poon, Crampton Electric Fish Lab, University of Central Florida, Copyright 2023
# A detailed guide about this program: https://lokpoon.github.io/moonshine_manual/sunlight_twilight_LED_scheduler.html

# Description:
# This script generates an LED_schedule_sun.csv schedule file for MoonShineP to re-create a sunlight/twilight regime.

# Load libraries ----------------------------

library(dplyr)
library(suncalc)
library(lubridate)
library(REdaS)
library(ggplot2)
library(beepr)
library(stats)
library(npreg)
library(progress)

#---------------------------START OF PARAMETER SETTINGS---------------------------

# (!) indicates a user specified setting

# Set working directory
setwd("/Users/lokpoon/Desktop") # (!) Set working directory. Place R program here. .csv and .jpg files will be saved to this directory

# Set the location and time ---------------------------
latitude <- -4.21528 # (!) Latitude in decimal degrees (e.g., -4.21528)
longitude <- -69.94056 # (!) Longitude in decimal degrees (e.g., -69.94056)

time_zone <- "EST" # (!) Set the time zone for the location set (e.g., “EST”). REMEMBER TO CHANGE THE TIME ZONE WHEN THE LOCATION IS CHANGED.
# For a list of time zone names, enter OlsonNames(tzdir = NULL) in R console
# Highly recommend using a time zone without DST. E.g., use "EST" instead of "America/New_York"
date_start <- "2023-03-01" # (!) Starting date of the simulation (YYYY-MM-DD)
time_start <- "18:00:00" # (!) Starting time of the simulation (hh:mm:ss)
duration_day <- 1 # (!) Duration of simulation in days

# LED strip configuration ---------------------------

theoretical_max <- 600 # (!) Define an intensity upper limit (in lx) so that the LED system is not instructed to exceed 100% output intensity.
## Refer to online MoonShineP Manual part 7.
## Increasing theoretical_max will reduce the illuminance to the LED.

diode_per_strip <- 144 # (!) Number of LEDs per strip
strip_count <- 4 # (!) Number of daisy-chained LED strips

# Apply color shift  ---------------------------
# Pick either to use realistic_sunlight or a manual spectral shift.
# If realistic_sunlight is TRUE, an automatic spectral shift is applied, and the manual spectral shift is ignored.
# If realistic_sunlight is FALSE, the manual spectral shift is applied.

# LED spectral control---------------------------
# A) Default realistic twilight and sunlight spectral change. 
realistic_sunlight <- TRUE # (!) TRUE to enable
# This automatically sets the color spectrum to a realistic color of sunlight and twilight. It simulates the color change during sunrise/set and twilight periods (Palmer & Johnsen 2015) according to the sun's altitude.
# If realistic_sunlight is enabled, it will override and ignore the manual spectral shift settings in the next section.

# B) Manual spectral shift (a constant shift, does not change with sun's altitude)
# This can be used to approximate a specific light spectrum of habitat or anthropogenic light.
# Input the intensity fraction (0-1) each LED color is outputting. Each is independent. 
white_fraction <- 1.0 # (!) White. Default = 1.0
red_fraction <- 0.08 # (!) Red. Default = 0.08
green_fraction <- 0.36 # (!) Green. Default = 0.36
blue_fraction <- 0.19 # (!) Blue. Default = 0.19
# The default values approximate the sunlight spectrum.
# To change color balance from white to, for example, a blue-shifted light, the user can decrease other color fractions except for blue_fraction, incrementally, until the color generated by lightbox reaches desired parameters on a spectrometer.
# Please recognize the narrow band nature of the RGB LED and utilize it accordingly.

#---------------------------END OF PARAMETER SETTINGS---------------------------

#---------------------------START OF ILLUMINATION COMPUTATION---------------------------

time_interval_minutes <- 1 # The temporal resolution of the simulation in minutes. Locked at 1 for MoonShineP to operate correctly.
bit8 <- 255 # Controllable light intensity level of the LEDs is 255 (8 bit).

# Start time formatting
date_time_start <- as_datetime(paste(date_start, time_start, sep = " ", collapse = NULL), tz = time_zone)
number_of_interval <- as.numeric(ddays(duration_day)) / as.numeric(dminutes(time_interval_minutes))

# Create an empty dataframe (to be filled during the for loop)
sun_value_table <- data.frame(matrix(ncol = 1, nrow = number_of_interval))
x <- c("x")
colnames(sun_value_table) <- x

# Create for loop [i] time interval list
time_interval_list <- seq(1, number_of_interval, by = 1) 

# Create a progress bar object
pb <- progress_bar$new(total = length(time_interval_list))

# Fill in empty data frame with suncalc data
for (i in time_interval_list) {
  sun_value_table[i, "datetime"] <- getMoonIllumination(date = date_time_start + (i - 1) * time_interval_minutes * 60)[1, "date"]
  sun_value_table[i, "sun_altitude"] <- rad2deg(getSunlightPosition(date = date_time_start + (i - 1) * time_interval_minutes * 60, lat = latitude, lon = longitude, keep = c("altitude"))[1, "altitude"]) #sun_altitude = altitude of the sun in degree
  pb$tick() # Update the progress bar
}
sun_value_table <- subset(sun_value_table, select = -c(x))

# Calculate twilight illuminance
# Following the polynomial function in Seidelmann (1992) p. 491
sun_value_table$twilight <- 0
sun_value_table$twilight <- ifelse(sun_value_table$sun_altitude < 0 & sun_value_table$sun_altitude > -0.8,
                                    10 ^ (2.88 + (22.26 * (sun_value_table$sun_altitude / 90)) - 207.64 * ((sun_value_table$sun_altitude / 90) ^ 2) + 1034.3 * ((sun_value_table$sun_altitude / 90) ^ 3)), sun_value_table$twilight)
sun_value_table$twilight <- ifelse(sun_value_table$sun_altitude < -0.8 & sun_value_table$sun_altitude > -5,
                                    10 ^ (2.88 + (21.81 * (sun_value_table$sun_altitude / 90)) - 258.11 * ((sun_value_table$sun_altitude / 90) ^ 2) - 858.36 * ((sun_value_table$sun_altitude / 90) ^ 3)), sun_value_table$twilight)
sun_value_table$twilight <- ifelse(sun_value_table$sun_altitude < -5 & sun_value_table$sun_altitude > -12,
                                    10 ^ (2.7 + (12.17 * (sun_value_table$sun_altitude / 90)) - 431.69 * ((sun_value_table$sun_altitude / 90) ^ 2) - 1899.83 * ((sun_value_table$sun_altitude / 90) ^ 3)), sun_value_table$twilight)
sun_value_table$twilight <- ifelse(sun_value_table$sun_altitude < -12 & sun_value_table$sun_altitude > -18,
                                    10 ^ (13.84 + (262.72 * (sun_value_table$sun_altitude / 90)) + 1447.42 * ((sun_value_table$sun_altitude / 90) ^ 2) + 2797.93 * ((sun_value_table$sun_altitude / 90) ^ 3)), sun_value_table$twilight)

# Calculate sunlight (SUN > 0 degree) illuminance---------------------------
# Following the polynomial function in Seidelmann (1992) p. 491
sun_value_table$sunlight <- 0
sun_value_table$sunlight <- ifelse(sun_value_table$sun_altitude > 20,
                                    10 ^ (3.74 + (3.97 * (sun_value_table$sun_altitude / 90)) - 4.07 * ((sun_value_table$sun_altitude / 90) ^ 2) + 1.47 * ((sun_value_table$sun_altitude / 90) ^ 3)), sun_value_table$sunlight)
sun_value_table$sunlight <- ifelse(sun_value_table$sun_altitude < 20 & sun_value_table$sun_altitude > 5,
                                    10 ^ (3.05 + (13.28 * (sun_value_table$sun_altitude / 90)) - 45.98 * ((sun_value_table$sun_altitude / 90) ^ 2) + 64.33 * ((sun_value_table$sun_altitude / 90) ^ 3)), sun_value_table$sunlight)
sun_value_table$sunlight <- ifelse(sun_value_table$sun_altitude < 5 & sun_value_table$sun_altitude > 0,
                                    10 ^ (2.88 + (22.26 * (sun_value_table$sun_altitude / 90)) - 207.64 * ((sun_value_table$sun_altitude / 90) ^ 2) + 1034.3 * ((sun_value_table$sun_altitude / 90) ^ 3)), sun_value_table$sunlight)

# Add sunlight and twilight together
sun_value_table$raw_twilight_sun <- sun_value_table$twilight + sun_value_table$sunlight # add twilight and sunlight illuminance together
sun_value_table$raw_twilight_sun <- illuminance_fraction * sun_value_table$raw_twilight_sun # apply illuminance_fraction
sun_value_table <- transform(sun_value_table, adjusted_twilight_sun = ifelse(raw_twilight_sun > theoretical_max, theoretical_max, raw_twilight_sun)) # apply the ceiling for sunlight recreation

#---------------------------END OF ILLUMINATION COMPUTATION---------------------------

#---------------------------GENERATE LED_schedule_sun.csv---------------------------

# scale the predicted illuminance to an intensity fraction by dividing it by the theoretical_max
recreate_intensity_fraction <- sun_value_table$adjusted_twilight_sun / theoretical_max

# To simulate realistic color change according to the sun altitude, create curve functions for each RGBW:
# Make a table of sun's altitude ~ LED intensity fraction for each RGBW
color_change_matrix <- matrix(c(90, 1, 0.08, 0.6, 0.4,
                                42, 1, 0.08, 0.6, 0.4,
                                12, 1, 0.08, 0.46, 0.26,
                                6, 1, 0.1, 0.4, 0.2,
                                0, 1, 0.16, 0.34, 0.12,
                                -2, 0.99, 0.3, 0.34, 0.13,
                                -4, 0.95, 0.4, 0.38, 0.18,
                                -6.5, 0.7, 0.15, 0.7, 0.9,
                                -18, 0.6, 0.08, 0.8, 1), ncol = 5, byrow = TRUE)

colnames(color_change_matrix) <- c("sun_altitude","white","red", "green", "blue")
color_change_matrix <- as.data.frame(color_change_matrix)

time_interval <- seq(1, nrow(sun_value_table), by = 1)
color_table <- data.frame(matrix(ncol = 1, nrow = nrow(sun_value_table)))
colnames(color_table) <- c("x")

# Fit a smooth spline curve to the table values
# (!) Remove commenting in the next 15 lines (plot & points) if you want to see how the LED color changes according to sun altitude:
white_curve <- ss(color_change_matrix$sun_altitude, color_change_matrix$white, df = 8, m = 1)
#plot(white_curve, ylim = c(0, 1), xlab = "sun_altitude", ylab = "led intensity", main = "color curve for white")
#points(color_change_matrix$sun_altitude, color_change_matrix$white)

red_curve <- ss(color_change_matrix$sun_altitude, color_change_matrix$red, df = 8, m = 1)
#plot(red_curve, ylim = c(0, 1), xlab = "sun_altitude", ylab = "led intensity", main = "color curve for red")
#points(color_change_matrix$sun_altitude, color_change_matrix$red)

green_curve <- ss(color_change_matrix$sun_altitude, color_change_matrix$green, df = 8, m = 1)
#plot(green_curve, ylim = c(0, 1), xlab = "sun_altitude", ylab = "led intensity", main = "color curve for green")
#points(color_change_matrix$sun_altitude, color_change_matrix$green)

blue_curve <- ss(color_change_matrix$sun_altitude, color_change_matrix$blue, df = 8, m = 1)
#plot(blue_curve, ylim = c(0, 1), xlab = "sun_altitude", ylab = "led intensity", main = "color curve for blue")
#points(color_change_matrix$sun_altitude, color_change_matrix$blue)

# Create a progress bar object
pb2 <- progress_bar$new(total = length(time_interval_list))

if (realistic_sunlight == TRUE) {
  for (i in time_interval) {
    color_table$datetime <- sun_value_table$datetime
    color_table$sun_altitude <- sun_value_table$sun_altitude
    
    color_table[i, "white"] <- predict(white_curve , color_table[i, "sun_altitude"] , deriv = 0)[1, 2]
    if (color_table[i, "white"] > 1) {color_table[i, "white"] <- 1}
    if (color_table[i, "white"] < 0) {color_table[i, "white"] <- 0}
    color_table$white <- round(color_table$white, digits = 2)
    
    color_table[i, "red"] <- predict(red_curve , color_table[i, "sun_altitude"] , deriv = 0)[1, 2]
    if (color_table[i, "red"] > 1) {color_table[i, "red"] <- 1}
    if (color_table[i, "red"] < 0) {color_table[i, "red"] <- 0}
    color_table$red <- round(color_table$red, digits = 2)
    
    color_table[i, "green"] <- predict(green_curve , color_table[i, "sun_altitude"] , deriv = 0)[1, 2]
    if (color_table[i, "green"] > 1) {color_table[i, "green"] <- 1}
    if (color_table[i, "green"] < 0) {color_table[i, "green"] <- 0}
    color_table$green <- round(color_table$green, digits = 2)
    
    color_table[i, "blue"] <- predict(blue_curve , color_table[i, "sun_altitude"] , deriv = 0)[1, 2]
    if (color_table[i, "blue"] > 1) {color_table[i, "blue"] <- 1}
    if (color_table[i, "blue"] < 0) {color_table[i, "blue"] <- 0}
    color_table$blue <- round(color_table$blue, digits = 2)
    pb2$tick() # Update the progress bar
    
    white_fraction <- 1.0 
    red_fraction <- 1.0 
    green_fraction <- 1.0 
    blue_fraction <- 1.0
  }
  }else {
    color_table$datetime <- sun_value_table$datetime
    color_table$sun_altitude <- sun_value_table$sun_altitude
    
    color_table$white <- 1
    color_table$red <- 1
    color_table$green <- 1
    color_table$blue <- 1
  }
color_table <- subset(color_table, select = -c(x))


#Calculate the RGBW crude and fine values for the light recreation
color_table$temp_white_intensity <- recreate_intensity_fraction * bit8 * white_fraction * color_table$white
color_table$crudewhite <- floor(color_table$temp_white_intensity)
color_table$wfine <- floor((color_table$temp_white_intensity - color_table$crudewhite) * diode_per_strip * strip_count)

color_table$temp_red_intensity <- recreate_intensity_fraction * bit8 * red_fraction * color_table$red
color_table$crudered <- floor(color_table$temp_red_intensity)
color_table$rfine <- floor((color_table$temp_red_intensity - color_table$crudered) * diode_per_strip * strip_count)

color_table$temp_green_intensity <- recreate_intensity_fraction * bit8 * green_fraction * color_table$green
color_table$crudegreen <- floor(color_table$temp_green_intensity)
color_table$gfine <- floor((color_table$temp_green_intensity - color_table$crudegreen) * diode_per_strip * strip_count)

color_table$temp_blue_intensity <- recreate_intensity_fraction * bit8 * blue_fraction * color_table$blue
color_table$crudeblue <- floor(color_table$temp_blue_intensity)
color_table$bfine <- floor((color_table$temp_blue_intensity - color_table$crudeblue) * diode_per_strip * strip_count)

#Fill sun_value_table with LED color crude and fine values. NA converted to 0.
sun_value_table$crudewhite <- color_table$crudewhite
sun_value_table <- transform(sun_value_table, crudewhite = ifelse(is.na(crudewhite), 0, crudewhite)) 

sun_value_table$wfine <- color_table$wfine
sun_value_table <- transform(sun_value_table, wfine = ifelse(is.na(wfine), 0, wfine)) 

sun_value_table$crudered <- color_table$crudered
sun_value_table <- transform(sun_value_table, crudered = ifelse(is.na(crudered), 0, crudered)) 

sun_value_table$rfine <- color_table$rfine
sun_value_table <- transform(sun_value_table, rfine = ifelse(is.na(rfine), 0, rfine))

sun_value_table$crudegreen <- color_table$crudegreen
sun_value_table <- transform(sun_value_table, crudegreen = ifelse(is.na(crudegreen), 0, crudegreen)) 

sun_value_table$gfine <- color_table$gfine
sun_value_table <- transform(sun_value_table, gfine = ifelse(is.na(gfine), 0, gfine))

sun_value_table$crudeblue <- color_table$crudeblue
sun_value_table <- transform(sun_value_table, crudeblue = ifelse(is.na(crudeblue), 0, crudeblue)) 

sun_value_table$bfine <- color_table$bfine
sun_value_table <- transform(sun_value_table, bfine = ifelse(is.na(bfine), 0, bfine))

sun_value_table <- subset(sun_value_table, select = -c(twilight, sunlight, raw_twilight_sun))

# Save twilight_sun_table csv file
write.csv(sun_value_table,"LED_schedule_sun.csv", row.names = TRUE)

# Explanation for the columns found in LED_schedule_sunlight_twilight).csv:
## datetime = The datetime in a standard format that R and moonshine_sun.py can read
## sun_altitude = The altitude of the sun. Positive/negative value means the sun is above/below the horizon, respectively.
## adjusted_twilight_sun = the combined illuminance of the sunlight and twilight, capped at the theoretical_max
## crude and fine LED values for each RGBW = the LED values that moonshine_sun.py will use instruct the LED at the given time

#---------------------------Plotting Section---------------------------

# Plot the sunlight and twilight illuminance that will be re-created.
# Dark gray areas depict dark periods (true night after astronomical twilight ended).
# Light gray areas indicate the periods of astronomical twilight.

# Create a clean ggplot theme
theme_rectangular_clean <-
  theme(axis.line = element_line(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank()) +
  theme(axis.text = element_text(size = 12, colour = 'black'),
        axis.title = element_text(size = 12, colour = 'black')) +
  theme(plot.title = element_text(size = 12)) +
  theme(plot.margin = unit(c(0.25,0.25,0.25,0.25),"cm"))

# Specify the time of night period and twilight period for shading
night_time <- filter(sun_value_table, sun_altitude < 0) %>% dplyr::select(datetime)
night_time <- as_datetime(night_time$datetime, tz = time_zone)

after_twilight_time <- filter(sun_value_table, sun_altitude < (-18)) %>% dplyr::select(datetime)
after_twilight_time <- as_datetime(after_twilight_time$datetime, tz =  time_zone)

day_time <- filter(sun_value_table, sun_altitude > 0) %>% dplyr::select(datetime)
day_time <- as_datetime(day_time$datetime, tz = time_zone)

#Plotting
plot_output <- ggplot() + theme_rectangular_clean +
  geom_rect(aes(xmin = night_time, # night period
                xmax = night_time + dminutes(time_interval_minutes),
                ymin = 0, ymax = Inf), fill = "grey88", alpha = 1, na.rm = TRUE) +
  geom_rect(aes(xmin = after_twilight_time, # after twilight
                xmax = after_twilight_time + dminutes(time_interval_minutes),
                ymin = 0, ymax = Inf), fill = "grey80", alpha = 1, na.rm = TRUE) +
  geom_line(data = sun_value_table, aes(x = datetime, y = adjusted_twilight_sun), colour = 'black', linewidth = 0.75) +
  scale_y_continuous(limits = c(0, 600), # change the y-axis range here
    breaks = c(seq(from = 0, to = 600, by = 50))) + # change the y-axis breaks here
  scale_x_datetime(date_breaks = "1 day") + # change the date break here for different x-axis label.
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) + # rotate date label 90 degree.
  labs(x = "", y = "predicted ground illuminance (lx)") 

plot_output

beep()

# To save plot, remove commenting in the next line:
ggsave("sunlight_twilight_output.png", plot_output, width = 4488, height = 2400, units = "px", scale = 1, dpi = 450)
## .png can be changed to .pdf to save as a vector file.
## However when exporting as .pdf, the shading transparency (alpha setting) might not look right. This is a limitation of R.


#---------------------------END OF SCRIPT---------------------------

# References ---------------------------  

# Allen, C. W. (1976). Astrophysical quantities (3rd ed. 1973, Repr. with corrections 1976). Athelone Press.; [Distributor for] U.S.A. and Canada, Humanities Press.
# Austin, R. H., Phillips, B. F., & Webb, D. J. (1976). A method for calculating moonlight illuminance at the earth’s surface. The Journal of Applied Ecology, 13(3), 741. https://doi.org/10.2307/2402251
# Buratti, B. J., Hillier, J. K., & Wang, M. (1996). The lunar opposition surge: Observations by clementine. Icarus, 124(2), 490–499. https://doi.org/10.1006/icar.1996.0225
# Hänel, A., Posch, T., Ribas, S. J., Aubé, M., Duriscoe, D., Jechow, A., Kollath, Z., Lolkema, D. E., Moore, C., Schmidt, N., Spoelstra, H., Wuchterl, G., & Kyba, C. C. M. (2018). Measuring night sky brightness: Methods and challenges. Journal of Quantitative Spectroscopy and Radiative Transfer, 205, 278–290. https://doi.org/10.1016/j.jqsrt.2017.09.008
# Krisciunas, K., & Schaefer, B. E. (1991). A model of the brightness of moonlight. Publications of the Astronomical Society of the Pacific, 103, 1033. https://doi.org/10.1086/132921
# Palmer, G., & Johnsen, S. (2015). Downwelling spectral irradiance during evening twilight as a function of the lunar phase. Applied Optics, 54(4), B85. https://doi.org/10.1364/AO.54.000B85
# Schaefer, B. E. (1990). Telescopic limiting magnitudes. Publications of the Astronomical Society of the Pacific, 102, 212. https://doi.org/10.1086/132629
# Seidelmann, P. K., United States Naval Observatory, & Great Britain (Eds.). (1992). Explanatory supplement to the Astronomical almanac (Rev. ed.). University Science Books.