import time                #this library is usedfrom rpi_ws281x import *  #to control the ledsimport argparseimport csv                #work with csv filesimport os#-------------------------------------------------------# function to clear terminal and clearing itLED_COUNT      = 288     # Number of LED pixels.LED_PIN        = 18      # GPIO pin connected to the pixels (18 uses PWM!).#LED_PIN        = 10      # GPIO pin connected to the pixels (10 uses SPI /dev/spidev0.0).LED_FREQ_HZ    = 800000  # LED signal frequency in hertz (usually 800khz)LED_DMA        = 10      # DMA channel to use for generating signal (try 10)LED_BRIGHTNESS = 255    # Set to 0 for darkest and 255 for brightestLED_INVERT     = False   # True to invert the signal (when using NPN transistor level shift)LED_CHANNEL    = 0       # set to '1' for GPIOs 13, 19, 41, 45 or 53LED_STRIP = ws.SK6812_STRIP_GRBW    # the GRBW order is correct for addressing the corrosponding channels on the BTF-Lighting LED strips. The order of the GRBW letters can be rearranged to accommodate another RGBW protocol.# Define functions which animate LEDs in various ways.# Define functions which animate LEDs in various ways.# this funtion gets the current time using the time library and returns itdef gettime():    # epoch time    etime = time.time()    # convert to local time    ltime = time.localtime(etime)    #return the results as separate variable in the format with two characters, for example January would be 01    return time.strftime("%Y", ltime),time.strftime("%m", ltime),time.strftime("%d", ltime),time.strftime("%H", ltime),time.strftime("%M", ltime),time.strftime("%S", ltime) #return epoch timedef timestart():    etime=time.time()    ltime= time.ctime(etime)    return etime#defines class Led, taking aclass led:    def __init__(self,r,g,b,w):        self.r=r        self.g=g        self.b=b        self.w=w#print the input for a specific Led on the stripdef printled(strip,i):  # opens log.txt to append  file = open("/home/pi/Desktop/control_moon/log.txt", "a")  # this is where the data is written to the file  file.write('\n| led ' + str(i) + ' r ' + str(strip[i].r) + ' g ' +str(strip[i].g) + ' b ' +str(strip[i].b) + ' w ' + str(strip[i].w) + '|')  file.close()  #print the same to the terminal  print("----------------------------")  print('| led ' + str(i) + ' r ' + str(strip[i].r) + ' g ' +str(strip[i].g) + ' b ' +str(strip[i].b) + ' w ' + str(strip[i].w) + '|')  print("----------------------------")#creates a "virtual strip" for calculations on which leds are powered and to what brightnesdef fillvstrip(LED_COUNT,STRIP,rfill,rfine,gfill,gfine,bfill,bfine,wfill,wfine):#all Leds in the strip are assigned the apropriate "fill" level, or the level out of 0-255 that each diode on each led will all be set at to begin with    for i in range(LED_COUNT):#red diode        STRIP[i].r =rfill;#green diode        STRIP[i].g =gfill;#blue diode        STRIP[i].b= bfill;#white diode        STRIP[i].w= wfill;#variables are set to one and are used as counters for increasing the leds properly    rcount1,rcount2=1,1    gcount1,gcount2=1,1    bcount1,bcount2=1,1     wcount1,wcount2=1,1#for every led in the range of the fine level, alter the red diode if neccisary. This would be the area of code to edit if altering the order the leds increase in brightness is neccisary    for i in range(rfine):    #if index is odd number, increase brightness of the matching number led       if i%2!=0:            #increase brigness by one           STRIP[i-rcount2].r = rfill+1            #increase counter           rcount2 +=1       else:           #if the index is an odd number, increase the of the leds starting from halfway down the strip.            STRIP[i+int((LED_COUNT/2))-rcount1+1].r = rfill+1             #counter            rcount1 +=1#for every led in the range of the fine level, alter the green diode if neccisary    for i in range(gfine):    #if odd number index       if i%2!=0:           # increase at i            STRIP[i-gcount2].g = gfill+1            gcount2 +=1       else:           # even index, start from halfway            STRIP[i+int((LED_COUNT/2))-gcount1+1].g = gfill+1             gcount1 +=1     #for every led in the range of the fine level, alter the blue diode if neccisary    for i in range(bfine):       if i%2!=0:           # increase at i           STRIP[i-bcount2].b = bfill+1           bcount2 +=1       else:           # even index, start from halfway            STRIP[i+int((LED_COUNT/2))-bcount1+1].b = bfill+1             bcount1 +=1#for every led in the range of the fine level, alter the white diode if neccisary    for i in range(wfine):        # if odd number index        if i % 2 != 0:            # increase at i            STRIP[i - wcount2].w = wfill + 1            wcount2 += 1        else:            # even index, start from halfway            STRIP[i + int((LED_COUNT / 2)) - wcount1 + 1].w = wfill + 1            wcount1 += 1    return STRIP #takes the strip and virtual strip as parameters. prints virtual strip to real stripdef colorWipe3(strip, vstrip):#for every LED    for i in range(strip.numPixels()):        #variable holds color made from the values found in the virtual strip        color=Color(vstrip[i].r,vstrip[i].g,vstrip[i].b,vstrip[i].w)        #Set pixel color of real led to virtual led level        strip.setPixelColor(i, color)    #execut changes    strip.show()       def clear():    command = 'clear'    if os.name in ('nt', 'dos'):  # If Machine is running on Windows, use cls        command = 'cls'    os.system(command)    clear()#funtion to report the row in which a search term in found a specific column#inputs are csv file, the term being searched for, and the title of the row you are searching indef search(filename,term):    #open the csv that is passed as filename    with open(filename, newline='') as csvfile:        #reader variable that can be parsed        reader = csv.DictReader(csvfile)        search=1          #parsing through all rows in the reader        for row in reader:            #when the a value is found in the column "datetime"  that matches the current time which is passed as the "term" being searched for            if row['datetime'] == term:                #open the log                file = open("/home/pi/Desktop/control_moon/log.txt", "a")                #print the data that is found in the csv                file.write("found at "+str(term)+" "+str(row['crudered'])+str(row['rfine'])+str(row['crudegreen'])+str(row['gfine'])+str(row['crudeblue'])+str(row['bfine'])+str(row['crudewhite'])+str(row['wfine']))                #close log                file.close()                                                                         #print the same to the terminal                print("found at ",term," ",row['crudered'],row['rfine'],row['crudegreen'],row['gfine'],row['crudeblue'],row['bfine'],row['crudewhite'],row['wfine'])                search=0                #returns the values found under their respective headers in the csv                return (row['crudered'],row['rfine'],row['crudegreen'],row['gfine'],row['crudeblue'],row['bfine'],row['crudewhite'],row['wfine'])      # Main program logic follows:if __name__ == '__main__':    # Process arguments    parser = argparse.ArgumentParser()    parser.add_argument('-c', '--clear', action='store_true', help='clear the display on exit')    args = parser.parse_args()    # Create NeoPixel object with appropriate configuration.    strip = Adafruit_NeoPixel(LED_COUNT, LED_PIN, LED_FREQ_HZ, LED_DMA, LED_INVERT, LED_BRIGHTNESS, LED_CHANNEL, LED_STRIP)    # Intialize the library (must be called once before other functions).    strip.begin()    # Initializing variables for future use    rfill,rfine,gfill,gfine,bfill,bfine,wfill,wfine=0,0,0,0,0,0,0,0    vstrip=[]    #in range of number of lights assigned by LED_COUNT    vstrip = [led(0,1,2,3) for i in range(LED_COUNT)]    #assign the variable vstrip by calling fillvstrip(). this initializes the strip and assigns all power levels the value of 0    vstrip = fillvstrip(LED_COUNT,vstrip,rfill,rfine,gfill,gfine,bfill,bfine,wfill,wfine)    try:        #clear log from last time the code was ran. if changing the name or location the log is saved to this is where you would change the address, along with all other lines that open the log        file = open("/home/pi/Desktop/control_moon/log.txt", "w")        file.close()        while True:            #get the real current time and assign appropriate variables for futute formatiing            year,month,day,hour,minute,second=gettime()            #this code will continue when the current time is a whole minute. this is because the data found in the csv is going to be at minute intervals            if(second=="00"):                #creates a string which is formated the same as the "datetime" row in the csv.                searcht=str(year)+"-"+str(month)+"-"+str(day)+" "+str(hour)+":"+str(minute)+":"+str(second)                #holds values returned by search function                result = search('/home/pi/Desktop/control_moon/LED_schedule_moon.csv', searcht)                #if result is not null,data was found                if result:                    #assign it to its respective variable                    rfill, rfine, gfill, gfine, bfill, bfine, wfill, wfine = result                else:                    #if null                    print("No matching term was found in the CSV file")                #casecatching for if there is a matching date time but no brightness values found at that time. this would occur when the moon is not above the horizion                if (rfill == "#VALUE!"):                    rfill = 1                if (rfine == "#VALUE!"):                    rfine = 1                if (gfill == "#VALUE!"):                    gfill = 1                if (gfine == "#VALUE!"):                    gfine = 1                if (bfill == "#VALUE!"):                    bfill = 1                if (bfine == "#VALUE!"):                    bfine = 1                if (wfill == "#VALUE!"):                    wfill = 1                if (wfine == "#VALUE!"):                    wfine = 1                                #casting all values to int data type                rfill, rfine, gfill, gfine, bfill, bfine, wfill, wfine = int(rfill), int(rfine), int(gfill), int(gfine), int(bfill), int(bfine), int(wfill), int(wfine)                                                                                      #fill the virtual strip with the values found in the csv                vstrip = fillvstrip(LED_COUNT, vstrip, rfill, rfine, gfill, gfine, bfill, bfine, wfill, wfine)                              #appies changes to real strip, making it match the data stored in the virtual strip                colorWipe3(strip, vstrip)                #prints what should be displaying on the light strip for the given number of leds                 for i in range(3):  # parameter is numer of leds from virtual strip that are printed.                    printled(vstrip, i)                time.sleep(52)  # parameter is time in seconds the program will wait before checking the clock again                   except KeyboardInterrupt:        if args.clear:            colorWipe(strip, Color(0,0,0,0), 10)